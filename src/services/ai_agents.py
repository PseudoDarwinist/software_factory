"""
AI Agents - Specialized AI agents for code analysis and project health monitoring
Event-driven agents that react to system changes and provide intelligent insights
"""

import logging
import json
import re
import asyncio
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum
from abc import ABC, abstractmethod

try:
    from ..services.context_aware_ai import get_context_aware_ai, AIContext
    from ..services.intelligence_engine import get_intelligence_engine, get_recommendation_engine
    from ..services.graph_service import GraphService
    from ..services.event_bus import get_event_bus
    from ..services.distributed_cache import get_distributed_cache
    from ..core.events import Event, EventType
    from ..models.project import Project
    from ..models.conversation import Conversation
    from ..models.system_map import SystemMap
except ImportError:
    from services.context_aware_ai import get_context_aware_ai, AIContext
    from services.intelligence_engine import get_intelligence_engine, get_recommendation_engine
    from services.graph_service import GraphService
    from services.event_bus import get_event_bus
    from services.distributed_cache import get_distributed_cache
    from core.events import Event, EventType
    from models.project import Project
    from models.conversation import Conversation
    from models.system_map import SystemMap

logger = logging.getLogger(__name__)


class AgentType(Enum):
    """Types of AI agents"""
    CODE_IMPACT_ANALYZER = "code_impact_analyzer"
    PROJECT_HEALTH_MONITOR = "project_health_monitor"
    DEFINE_AGENT = "define_agent"
    ARCHITECTURE_ADVISOR = "architecture_advisor"
    SECURITY_SCANNER = "security_scanner"
    PERFORMANCE_OPTIMIZER = "performance_optimizer"


class AlertLevel(Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"


@dataclass
class AgentAlert:
    """Alert generated by an AI agent"""
    agent_type: AgentType
    alert_level: AlertLevel
    title: str
    description: str
    project_id: Optional[int]
    recommendations: List[str]
    metadata: Dict[str, Any]
    created_at: datetime


class BaseAIAgent(ABC):
    """Base class for AI agents"""
    
    def __init__(self, agent_type: AgentType):
        self.agent_type = agent_type
        self.context_ai = get_context_aware_ai()
        self.intelligence_engine = get_intelligence_engine()
        self.recommendation_engine = get_recommendation_engine()
        self.cache = get_distributed_cache()
        self.event_bus = get_event_bus()
        self.is_active = False
        
    def start(self):
        """Start the agent and subscribe to relevant events"""
        self.is_active = True
        self._subscribe_to_events()
        logger.info(f"AI Agent {self.agent_type.value} started")
    
    def stop(self):
        """Stop the agent and unsubscribe from events"""
        self.is_active = False
        logger.info(f"AI Agent {self.agent_type.value} stopped")
    
    @abstractmethod
    def _subscribe_to_events(self):
        """Subscribe to relevant events"""
        pass
    
    @abstractmethod
    def analyze(self, event_data: Dict[str, Any]) -> Optional[AgentAlert]:
        """Analyze event data and return alert if needed"""
        pass
    
    def _create_alert(self, level: AlertLevel, title: str, description: str,
                     project_id: Optional[int] = None, recommendations: List[str] = None,
                     metadata: Dict[str, Any] = None) -> AgentAlert:
        """Create an agent alert"""
        return AgentAlert(
            agent_type=self.agent_type,
            alert_level=level,
            title=title,
            description=description,
            project_id=project_id,
            recommendations=recommendations or [],
            metadata=metadata or {},
            created_at=datetime.utcnow()
        )
    
    def _should_analyze(self, event_data: Dict[str, Any]) -> bool:
        """Determine if this event should be analyzed"""
        return self.is_active
    
    def _cache_alert(self, alert: AgentAlert):
        """Cache alert for retrieval"""
        cache_key = f"agent_alert_{alert.agent_type.value}_{alert.project_id}_{int(alert.created_at.timestamp())}"
        self.cache.set(
            cache_key,
            alert.__dict__,
            ttl=3600,  # Cache for 1 hour
            namespace='ai_agents'
        )


class CodeImpactAnalyzer(BaseAIAgent):
    """AI agent that analyzes code changes and their potential impact"""
    
    def __init__(self):
        super().__init__(AgentType.CODE_IMPACT_ANALYZER)
        
    def _subscribe_to_events(self):
        """Subscribe to code-related events"""
        self.event_bus.subscribe('system_map.generated', self._handle_system_map_event)
        self.event_bus.subscribe('conversation.created', self._handle_conversation_event)
        self.event_bus.subscribe('project.updated', self._handle_project_update_event)
    
    def _handle_system_map_event(self, event: Event):
        """Handle system map generation events"""
        try:
            if not self._should_analyze(event.data):
                return
            
            alert = self.analyze_system_map_impact(event.data)
            if alert:
                self._cache_alert(alert)
                logger.info(f"Code impact alert generated: {alert.title}")
                
        except Exception as e:
            logger.error(f"Error handling system map event: {e}")
    
    def _handle_conversation_event(self, event: Event):
        """Handle conversation events for code discussions"""
        try:
            if not self._should_analyze(event.data):
                return
            
            alert = self.analyze_code_discussion_impact(event.data)
            if alert:
                self._cache_alert(alert)
                logger.info(f"Code discussion alert generated: {alert.title}")
                
        except Exception as e:
            logger.error(f"Error handling conversation event: {e}")
    
    def _handle_project_update_event(self, event: Event):
        """Handle project update events"""
        try:
            if not self._should_analyze(event.data):
                return
            
            alert = self.analyze_project_change_impact(event.data)
            if alert:
                self._cache_alert(alert)
                logger.info(f"Project change alert generated: {alert.title}")
                
        except Exception as e:
            logger.error(f"Error handling project update event: {e}")
    
    def analyze_system_map_impact(self, event_data: Dict[str, Any]) -> Optional[AgentAlert]:
        """Analyze system map for architectural impact"""
        try:
            project_id = event_data.get('project_id')
            if not project_id:
                return None
            
            # Get latest system map
            system_map = SystemMap.query.filter_by(project_id=project_id).order_by(SystemMap.created_at.desc()).first()
            if not system_map or not system_map.map_data:
                return None
            
            # Analyze complexity and potential issues
            map_analysis = self._analyze_system_map_complexity(system_map.map_data)
            
            if map_analysis['complexity_score'] > 80:
                return self._create_alert(
                    level=AlertLevel.WARNING,
                    title="High Architectural Complexity Detected",
                    description=f"System map shows complexity score of {map_analysis['complexity_score']}/100. Consider architectural refactoring.",
                    project_id=project_id,
                    recommendations=[
                        "Break down monolithic components into smaller services",
                        "Reduce coupling between modules",
                        "Consider implementing design patterns for complexity management",
                        "Review and simplify data flow architecture"
                    ],
                    metadata={
                        'complexity_analysis': map_analysis,
                        'system_map_id': system_map.id
                    }
                )
            
            # Check for potential security issues
            security_issues = self._detect_security_patterns(system_map.map_data)
            if security_issues:
                return self._create_alert(
                    level=AlertLevel.WARNING,
                    title="Potential Security Concerns Detected",
                    description=f"Found {len(security_issues)} potential security concerns in system architecture.",
                    project_id=project_id,
                    recommendations=[
                        "Review authentication and authorization patterns",
                        "Ensure proper input validation at all entry points",
                        "Implement secure communication protocols",
                        "Add security scanning to CI/CD pipeline"
                    ],
                    metadata={
                        'security_issues': security_issues,
                        'system_map_id': system_map.id
                    }
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error analyzing system map impact: {e}")
            return None
    
    def analyze_code_discussion_impact(self, event_data: Dict[str, Any]) -> Optional[AgentAlert]:
        """Analyze conversation for code change implications"""
        try:
            conversation_id = event_data.get('conversation_id')
            project_id = event_data.get('project_id')
            
            if not conversation_id or not project_id:
                return None
            
            conversation = Conversation.query.get(conversation_id)
            if not conversation or not conversation.messages:
                return None
            
            # Analyze conversation for breaking changes
            breaking_changes = self._detect_breaking_changes(conversation.messages)
            if breaking_changes:
                return self._create_alert(
                    level=AlertLevel.CRITICAL,
                    title="Potential Breaking Changes Discussed",
                    description=f"Conversation indicates {len(breaking_changes)} potential breaking changes.",
                    project_id=project_id,
                    recommendations=[
                        "Create compatibility layer for breaking changes",
                        "Update API versioning strategy",
                        "Notify dependent teams of changes",
                        "Plan migration strategy for existing users"
                    ],
                    metadata={
                        'breaking_changes': breaking_changes,
                        'conversation_id': conversation_id
                    }
                )
            
            # Check for performance implications
            performance_issues = self._detect_performance_implications(conversation.messages)
            if performance_issues:
                return self._create_alert(
                    level=AlertLevel.WARNING,
                    title="Performance Impact Detected",
                    description="Discussion suggests changes that may impact system performance.",
                    project_id=project_id,
                    recommendations=[
                        "Conduct performance testing before deployment",
                        "Monitor key performance metrics",
                        "Consider caching strategies",
                        "Review database query optimization"
                    ],
                    metadata={
                        'performance_issues': performance_issues,
                        'conversation_id': conversation_id
                    }
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error analyzing code discussion impact: {e}")
            return None
    
    def analyze_project_change_impact(self, event_data: Dict[str, Any]) -> Optional[AgentAlert]:
        """Analyze project changes for broader impact"""
        try:
            project_id = event_data.get('project_id')
            if not project_id:
                return None
            
            # Get project ecosystem to understand impact scope
            ecosystem = GraphService.find_related_entities(
                entity_type='project',
                entity_id=str(project_id),
                max_depth=2
            )
            
            if len(ecosystem) > 10:  # High connectivity
                return self._create_alert(
                    level=AlertLevel.INFO,
                    title="High Impact Project Change",
                    description=f"Project changes may affect {len(ecosystem)} connected entities.",
                    project_id=project_id,
                    recommendations=[
                        "Notify stakeholders of project changes",
                        "Review dependent systems for compatibility",
                        "Plan coordinated rollout strategy",
                        "Update documentation and integration guides"
                    ],
                    metadata={
                        'ecosystem_size': len(ecosystem),
                        'connected_entities': ecosystem[:5]  # Top 5 for brevity
                    }
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error analyzing project change impact: {e}")
            return None
    
    def analyze(self, event_data: Dict[str, Any]) -> Optional[AgentAlert]:
        """Main analysis method"""
        event_type = event_data.get('event_type', '')
        
        if 'system_map' in event_type:
            return self.analyze_system_map_impact(event_data)
        elif 'conversation' in event_type:
            return self.analyze_code_discussion_impact(event_data)
        elif 'project' in event_type:
            return self.analyze_project_change_impact(event_data)
        
        return None
    
    def _analyze_system_map_complexity(self, map_data: Any) -> Dict[str, Any]:
        """Analyze system map for complexity metrics"""
        try:
            data_str = json.dumps(map_data) if isinstance(map_data, dict) else str(map_data)
            
            # Count components, connections, and layers
            component_count = data_str.count('component') + data_str.count('service') + data_str.count('module')
            connection_count = data_str.count('->') + data_str.count('connects') + data_str.count('calls')
            layer_count = data_str.count('layer') + data_str.count('tier')
            
            # Calculate complexity score
            complexity_score = min(100, (component_count * 5) + (connection_count * 3) + (layer_count * 10))
            
            return {
                'complexity_score': complexity_score,
                'component_count': component_count,
                'connection_count': connection_count,
                'layer_count': layer_count
            }
            
        except Exception as e:
            logger.error(f"Error analyzing system map complexity: {e}")
            return {'complexity_score': 0}
    
    def _detect_security_patterns(self, map_data: Any) -> List[str]:
        """Detect potential security issues in system map"""
        issues = []
        data_str = json.dumps(map_data).lower() if isinstance(map_data, dict) else str(map_data).lower()
        
        # Check for common security anti-patterns
        if 'http://' in data_str and 'api' in data_str:
            issues.append("Unsecured HTTP API endpoints detected")
        
        if 'password' in data_str and 'plain' in data_str:
            issues.append("Plain text password storage indicated")
        
        if 'admin' in data_str and 'public' in data_str:
            issues.append("Public admin interface detected")
        
        if 'database' in data_str and not any(sec in data_str for sec in ['ssl', 'tls', 'encrypted']):
            issues.append("Database connection may not be encrypted")
        
        return issues
    
    def _detect_breaking_changes(self, messages: List[Dict]) -> List[str]:
        """Detect potential breaking changes in conversation"""
        breaking_changes = []
        
        for message in messages:
            content = message.get('content', '').lower()
            
            # Look for breaking change indicators
            if any(phrase in content for phrase in [
                'breaking change', 'remove', 'delete', 'deprecate',
                'incompatible', 'major version', 'api change'
            ]):
                breaking_changes.append(f"Breaking change discussed: {content[:100]}...")
        
        return breaking_changes
    
    def _detect_performance_implications(self, messages: List[Dict]) -> List[str]:
        """Detect performance implications in conversation"""
        performance_issues = []
        
        for message in messages:
            content = message.get('content', '').lower()
            
            # Look for performance-related keywords
            if any(keyword in content for keyword in [
                'slow', 'performance', 'optimization', 'bottleneck',
                'memory', 'cpu', 'database query', 'caching'
            ]):
                performance_issues.append(f"Performance concern: {content[:100]}...")
        
        return performance_issues


class ProjectHealthMonitor(BaseAIAgent):
    """AI agent that monitors project health and provides predictive alerts"""
    
    def __init__(self):
        super().__init__(AgentType.PROJECT_HEALTH_MONITOR)
        
    def _subscribe_to_events(self):
        """Subscribe to project health events"""
        self.event_bus.subscribe('project.created', self._handle_project_event)
        self.event_bus.subscribe('project.updated', self._handle_project_event)
        self.event_bus.subscribe('conversation.created', self._handle_activity_event)
        self.event_bus.subscribe('system_map.generated', self._handle_activity_event)
    
    def _handle_project_event(self, event: Event):
        """Handle project lifecycle events"""
        try:
            if not self._should_analyze(event.data):
                return
            
            alert = self.analyze_project_health(event.data)
            if alert:
                self._cache_alert(alert)
                logger.info(f"Project health alert generated: {alert.title}")
                
        except Exception as e:
            logger.error(f"Error handling project event: {e}")
    
    def _handle_activity_event(self, event: Event):
        """Handle project activity events"""
        try:
            if not self._should_analyze(event.data):
                return
            
            alert = self.analyze_activity_patterns(event.data)
            if alert:
                self._cache_alert(alert)
                logger.info(f"Activity pattern alert generated: {alert.title}")
                
        except Exception as e:
            logger.error(f"Error handling activity event: {e}")
    
    def analyze_project_health(self, event_data: Dict[str, Any]) -> Optional[AgentAlert]:
        """Analyze overall project health"""
        try:
            project_id = event_data.get('project_id')
            if not project_id:
                return None
            
            # Get comprehensive project analysis
            complexity = self.intelligence_engine.analyze_project_complexity(project_id)
            activity = self.intelligence_engine.analyze_project_activity(project_id)
            
            # Check for health issues
            health_score = self._calculate_health_score(complexity, activity)
            
            if health_score < 30:  # Poor health
                return self._create_alert(
                    level=AlertLevel.CRITICAL,
                    title="Poor Project Health Detected",
                    description=f"Project health score is {health_score}/100. Immediate attention required.",
                    project_id=project_id,
                    recommendations=[
                        "Review project status and priorities",
                        "Increase team activity and engagement",
                        "Simplify project complexity where possible",
                        "Consider project restructuring or archival"
                    ],
                    metadata={
                        'health_score': health_score,
                        'complexity_analysis': complexity,
                        'activity_analysis': activity
                    }
                )
            
            elif health_score < 60:  # Declining health
                return self._create_alert(
                    level=AlertLevel.WARNING,
                    title="Declining Project Health",
                    description=f"Project health score is {health_score}/100. Monitor closely.",
                    project_id=project_id,
                    recommendations=[
                        "Increase project activity",
                        "Review and address complexity issues",
                        "Ensure regular team communication",
                        "Update project documentation"
                    ],
                    metadata={
                        'health_score': health_score,
                        'complexity_analysis': complexity,
                        'activity_analysis': activity
                    }
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error analyzing project health: {e}")
            return None
    
    def analyze_activity_patterns(self, event_data: Dict[str, Any]) -> Optional[AgentAlert]:
        """Analyze project activity patterns for anomalies"""
        try:
            project_id = event_data.get('project_id')
            if not project_id:
                return None
            
            # Check for unusual activity patterns
            recent_activity = self._get_recent_activity_pattern(project_id)
            
            if recent_activity['spike_detected']:
                return self._create_alert(
                    level=AlertLevel.INFO,
                    title="Unusual Activity Spike Detected",
                    description=f"Project activity has increased by {recent_activity['increase_percentage']}% recently.",
                    project_id=project_id,
                    recommendations=[
                        "Monitor resource usage and performance",
                        "Ensure adequate infrastructure scaling",
                        "Review recent changes for stability",
                        "Consider team coordination needs"
                    ],
                    metadata=recent_activity
                )
            
            elif recent_activity['decline_detected']:
                return self._create_alert(
                    level=AlertLevel.WARNING,
                    title="Activity Decline Detected",
                    description=f"Project activity has decreased by {recent_activity['decrease_percentage']}% recently.",
                    project_id=project_id,
                    recommendations=[
                        "Check with team for blockers or issues",
                        "Review project priorities and deadlines",
                        "Consider resource reallocation",
                        "Update project status and communication"
                    ],
                    metadata=recent_activity
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error analyzing activity patterns: {e}")
            return None
    
    def analyze(self, event_data: Dict[str, Any]) -> Optional[AgentAlert]:
        """Main analysis method"""
        event_type = event_data.get('event_type', '')
        
        if 'project' in event_type:
            return self.analyze_project_health(event_data)
        else:
            return self.analyze_activity_patterns(event_data)
    
    def _calculate_health_score(self, complexity: Dict, activity: Dict) -> int:
        """Calculate overall project health score (0-100)"""
        try:
            # Start with base score
            health_score = 100
            
            # Penalize high complexity
            complexity_score = complexity.get('complexity_score', 0)
            if complexity_score > 70:
                health_score -= (complexity_score - 70) * 2
            
            # Penalize low activity
            activity_level = activity.get('activity_level', 'dormant')
            activity_penalties = {
                'dormant': 40,
                'low': 20,
                'medium': 5,
                'high': 0
            }
            health_score -= activity_penalties.get(activity_level, 40)
            
            # Bonus for good recent activity
            recent_conversations = activity.get('recent_conversations', 0)
            if recent_conversations > 5:
                health_score += min(10, recent_conversations - 5)
            
            return max(0, min(100, health_score))
            
        except Exception as e:
            logger.error(f"Error calculating health score: {e}")
            return 50  # Default neutral score
    
    def _get_recent_activity_pattern(self, project_id: int) -> Dict[str, Any]:
        """Analyze recent activity patterns"""
        try:
            # Get conversations from last 7 days vs previous 7 days
            now = datetime.utcnow()
            week_ago = now - timedelta(days=7)
            two_weeks_ago = now - timedelta(days=14)
            
            recent_convs = Conversation.query.filter(
                Conversation.project_id == project_id,
                Conversation.created_at >= week_ago
            ).count()
            
            previous_convs = Conversation.query.filter(
                Conversation.project_id == project_id,
                Conversation.created_at >= two_weeks_ago,
                Conversation.created_at < week_ago
            ).count()
            
            # Calculate change
            if previous_convs == 0:
                change_percentage = 100 if recent_convs > 0 else 0
            else:
                change_percentage = ((recent_convs - previous_convs) / previous_convs) * 100
            
            return {
                'recent_conversations': recent_convs,
                'previous_conversations': previous_convs,
                'change_percentage': change_percentage,
                'spike_detected': change_percentage > 100,
                'decline_detected': change_percentage < -50,
                'increase_percentage': max(0, change_percentage),
                'decrease_percentage': abs(min(0, change_percentage))
            }
            
        except Exception as e:
            logger.error(f"Error getting activity pattern: {e}")
            return {'spike_detected': False, 'decline_detected': False}


class AIAgentManager:
    """Manager for all AI agents"""
    
    def __init__(self):
        self.agents: Dict[AgentType, BaseAIAgent] = {}
        self.cache = get_distributed_cache()
        
    def register_agent(self, agent: BaseAIAgent):
        """Register an AI agent"""
        self.agents[agent.agent_type] = agent
        logger.info(f"Registered AI agent: {agent.agent_type.value}")
    
    def start_all_agents(self):
        """Start all registered agents"""
        for agent in self.agents.values():
            agent.start()
        logger.info(f"Started {len(self.agents)} AI agents")
    
    def stop_all_agents(self):
        """Stop all registered agents"""
        for agent in self.agents.values():
            agent.stop()
        logger.info("Stopped all AI agents")
    
    def get_agent(self, agent_type: AgentType) -> Optional[BaseAIAgent]:
        """Get specific agent by type"""
        return self.agents.get(agent_type)
    
    def get_recent_alerts(self, project_id: Optional[int] = None, 
                         hours: int = 24) -> List[AgentAlert]:
        """Get recent alerts from all agents"""
        try:
            # This is a simplified implementation
            # In production, you'd want a proper alert storage system
            
            alerts = []
            cache_pattern = f"agent_alert_*_{project_id}_*" if project_id else "agent_alert_*"
            
            # Note: This is a placeholder - you'd need to implement proper alert retrieval
            # from cache or database based on your caching strategy
            
            return alerts
            
        except Exception as e:
            logger.error(f"Error getting recent alerts: {e}")
            return []


# Global instances
ai_agent_manager = None


def get_ai_agent_manager() -> AIAgentManager:
    """Get the global AI agent manager"""
    global ai_agent_manager
    if ai_agent_manager is None:
        ai_agent_manager = AIAgentManager()
        
        # Register default agents
        ai_agent_manager.register_agent(CodeImpactAnalyzer())
        ai_agent_manager.register_agent(ProjectHealthMonitor())
        
        # Register DefineAgent bridge
        try:
            from .define_agent_bridge import get_define_agent_bridge
            define_agent_bridge = get_define_agent_bridge()
            ai_agent_manager.register_agent(define_agent_bridge)
            logger.info("DefineAgent bridge registered successfully")
        except Exception as e:
            logger.error(f"Failed to register DefineAgent bridge: {e}")
        
    return ai_agent_manager


def init_ai_agents() -> AIAgentManager:
    """Initialize the AI agent system and start all registered agents."""
    manager = get_ai_agent_manager()  # This will create and register default agents if not already done
    manager.start_all_agents()
    logger.info("AI agent system initialized and started.")
    return manager